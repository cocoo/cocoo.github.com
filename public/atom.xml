<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Cocoo Blog]]></title>
  <link href="http://cocoo.github.com/atom.xml" rel="self"/>
  <link href="http://cocoo.github.com/"/>
  <updated>2013-03-07T18:14:46+08:00</updated>
  <id>http://cocoo.github.com/</id>
  <author>
    <name><![CDATA[cocoo]]></name>
    <email><![CDATA[cocoo.dai@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[mxgraph笔记5【参数说明】]]></title>
    <link href="http://cocoo.github.com/blog/2013/03/07/mxgraphbi-ji-5/"/>
    <updated>2013-03-07T16:10:00+08:00</updated>
    <id>http://cocoo.github.com/blog/2013/03/07/mxgraphbi-ji-5</id>
    <content type="html"><![CDATA[<h3>mxStylesheet内参数说明</h3>

<pre><code>&lt;mxStylesheet as="stylesheet"&gt;
    &lt;add as="text"&gt; &lt;!-- 指定为text追加样式 --&gt;
        &lt;add as="shape" value="rectangle"/&gt;
        &lt;add as="perimeter" value="trianglePerimeter"/&gt;
        &lt;add as="fontSize" value="12"/&gt;
        &lt;add as="align" value="left"/&gt;
        &lt;add as="verticalAlign" value="top"/&gt;
        &lt;add as="shadow" value="0"/&gt;
        &lt;add as="strokeColor" value="none"/&gt;
        &lt;add as="fillColor" value="none"/&gt;
        &lt;add as="gradientColor" value="none"/&gt;
    &lt;/add&gt;
&lt;/mxStylesheet&gt;
</code></pre>

<ul>
<li>perimeter:连接点类型，可选的由ellipsePerimeter，rectanglePerimeter，rhombusPerimeter，trianglePerimeter</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mxgraph笔记2【xml配置】]]></title>
    <link href="http://cocoo.github.com/blog/2013/03/07/mxgraphbi-ji2/"/>
    <updated>2013-03-07T13:05:00+08:00</updated>
    <id>http://cocoo.github.com/blog/2013/03/07/mxgraphbi-ji2</id>
    <content type="html"><![CDATA[<p>在mxgraph中可以使用mxEditor读取xml格式的配置，通过xml定义构建toolbar，graph，shape等。</p>

<!--more-->


<h3>xml文件格式说明：</h3>

<pre><code>&lt;mxEditor defaultGroup="group" defaultEdge="connector"&gt;
&lt;!-- 
    The following line is used to dynamically add a configuration hook for various backends.
    The hook must have an ASP.NET extension because IIS does not handle any other extensions.
    In the Dotnet and Java server examples, this hook is implemented so that it returns the
    required configuration for using a backend, namely, the diagrameditor-backend.xml 
    in the java and dotnet directories, respectively.
 --&gt;
    &lt;!-- 引入按键绑定和右键弹出定义 --&gt;
    &lt;include name="config/editor-commons.xml"/&gt;
    &lt;!-- 定义onInit --&gt;
    &lt;add as="onInit"&gt;&lt;![CDATA[
        function ()
        {
            onInit(this);
        }
    ]]&gt;&lt;/add&gt;
    &lt;!-- 页面ui绑定 --&gt;
    &lt;ui&gt;
        &lt;add as="graph" element="graph"/&gt;
        &lt;add as="status" element="status"/&gt;
        &lt;add as="toolbar" element="toolbar"/&gt;
    &lt;/ui&gt;
    &lt;!-- 定义各形状初始化时的值 --&gt;
    &lt;Array as="templates"&gt;
        &lt;add as="group"&gt;
            &lt;Group label="" href=""&gt;
                &lt;mxCell vertex="1" style="group" connectable="0"/&gt;
            &lt;/Group&gt;
        &lt;/add&gt;
        &lt;add as="connector"&gt;
            &lt;Connector label="" href=""&gt;
                &lt;mxCell edge="1"&gt;
                    &lt;mxGeometry as="geometry" relative="1"/&gt;
                &lt;/mxCell&gt;
            &lt;/Connector&gt;
        &lt;/add&gt;
        &lt;add as="container"&gt;
            &lt;Container label="Container" href=""&gt;
                &lt;mxCell vertex="1" style="swimlane" connectable="0"&gt;
                    &lt;mxGeometry as="geometry" width="200" height="200"/&gt;
                &lt;/mxCell&gt;
            &lt;/Container&gt;
        &lt;/add&gt;
        &lt;add as="rectangle"&gt;
            &lt;Rect label="Rectangle" href=""&gt;
                &lt;mxCell vertex="1"&gt; 
                    &lt;mxGeometry as="geometry" width="80" height="40"/&gt;
                &lt;/mxCell&gt;
            &lt;/Rect&gt;
        &lt;/add&gt;
        &lt;add as="text"&gt;
            &lt;Text label="Text Here" href=""&gt;
                &lt;mxCell vertex="1" style="text"&gt;    
                    &lt;mxGeometry as="geometry" width="80" height="20"/&gt;
                &lt;/mxCell&gt;
            &lt;/Text&gt;
        &lt;/add&gt;
        &lt;add as="image"&gt;
            &lt;Image label="" href=""&gt;
                &lt;mxCell vertex="1" style="image"&gt;   
                    &lt;mxGeometry as="geometry" width="80" height="50"/&gt;
                &lt;/mxCell&gt;
            &lt;/Image&gt;
        &lt;/add&gt;
        &lt;add as="rounded"&gt;
            &lt;Roundrect label="Rounded" href=""&gt;
                &lt;mxCell vertex="1" style="rounded"&gt;     
                    &lt;mxGeometry as="geometry" width="80" height="40"/&gt;
                &lt;/mxCell&gt;
            &lt;/Roundrect&gt;
        &lt;/add&gt;
        &lt;add as="shape"&gt;
            &lt;Shape label="Shape" href=""&gt;
                &lt;mxCell vertex="1" style="ellipse"&gt;     
                    &lt;mxGeometry as="geometry" width="60" height="60"/&gt;
                &lt;/mxCell&gt;
            &lt;/Shape&gt;
        &lt;/add&gt;
        &lt;add as="actor"&gt;
            &lt;Shape label="Shape" href=""&gt;
                &lt;mxCell vertex="1" style="actor"&gt;       
                    &lt;mxGeometry as="geometry" width="40" height="60"/&gt;
                &lt;/mxCell&gt;
            &lt;/Shape&gt;
        &lt;/add&gt;
        &lt;add as="cloud"&gt;
            &lt;Shape label="Shape" href=""&gt;
                &lt;mxCell vertex="1" style="cloud"&gt;       
                    &lt;mxGeometry as="geometry" width="80" height="60"/&gt;
                &lt;/mxCell&gt;
            &lt;/Shape&gt;
        &lt;/add&gt;
        &lt;add as="hline"&gt;
            &lt;Shape label="" href=""&gt;
                &lt;mxCell vertex="1" style="ellipse"&gt;     
                    &lt;mxGeometry as="geometry" width="60" height="10"/&gt;
                &lt;/mxCell&gt;
            &lt;/Shape&gt;
        &lt;/add&gt;
    &lt;/Array&gt;
    &lt;mxGraph as="graph" alternateEdgeStyle="verticalConnector" allowLoops="1" dropEnabled="1"&gt;
        &lt;add as="isAutoSizeCell"&gt;&lt;![CDATA[
            function(cell)
            {
                return mxUtils.isNode(this.model.getValue(cell), 'text');
            }
        ]]&gt;&lt;/add&gt;
        &lt;add as="isSwimlane"&gt;&lt;![CDATA[
            function (cell)
            {
                return mxUtils.isNode(this.model.getValue(cell), 'container');
            }
        ]]&gt;&lt;/add&gt;
        &lt;add as="getTooltipForCell"&gt;&lt;![CDATA[
            function(cell)
            {
                return '&lt;b&gt;'+cell.getAttribute('label')+
                        '&lt;/b&gt; ('+cell.getId()+')'+
                        '&lt;br&gt;Style: '+cell.getStyle()+
                        '&lt;br&gt;Connections: '+cell.getEdgeCount()+
                        '&lt;br&gt;Children: '+cell.getChildCount();
            }
        ]]&gt;&lt;/add&gt;
        &lt;add as="convertValueToString"&gt;&lt;![CDATA[
            function(cell)
            {
                return cell.getAttribute('label');
            }
        ]]&gt;&lt;/add&gt;
        &lt;!-- 各Shape的样式 --&gt;
        &lt;mxStylesheet as="stylesheet"&gt;
            &lt;add as="text"&gt;
                &lt;add as="shape" value="rectangle"/&gt;
                &lt;add as="perimeter" value="rectanglePerimeter"/&gt;
                &lt;add as="fontSize" value="12"/&gt;
                &lt;add as="align" value="left"/&gt;
                &lt;add as="verticalAlign" value="top"/&gt;
                &lt;add as="shadow" value="0"/&gt;
                &lt;add as="strokeColor" value="none"/&gt;
                &lt;add as="fillColor" value="none"/&gt;
                &lt;add as="gradientColor" value="none"/&gt;
            &lt;/add&gt;
            &lt;add as="defaultVertex" extend="text"&gt;
                &lt;add as="shape" value="rectangle"/&gt;
                &lt;add as="fontSize" value="11"/&gt;
                &lt;add as="align" value="center"/&gt;
                &lt;add as="verticalAlign" value="middle"/&gt;
                &lt;add as="shadow" value="1"/&gt;
                &lt;add as="strokeColor" value="#C3D9FF"/&gt;
                &lt;add as="fillColor" value="#C3D9FF"/&gt;
                &lt;add as="gradientColor" value="white"/&gt;
            &lt;/add&gt;
            &lt;add as="group"&gt;
                &lt;add as="shape" value="rectangle"/&gt;
                &lt;add as="perimeter" value="rectanglePerimeter"/&gt;
                &lt;add as="fontSize" value="10"/&gt;
                &lt;add as="align" value="center"/&gt;
                &lt;add as="verticalAlign" value="middle"/&gt;
                &lt;add as="strokeColor" value="gray"/&gt;
                &lt;add as="dashed" value="1"/&gt;
            &lt;/add&gt;
            &lt;add as="defaultEdge"&gt;
                &lt;add as="shape" value="connector"/&gt;
                &lt;add as="fontSize" value="10"/&gt;
                &lt;add as="align" value="center"/&gt;
                &lt;add as="verticalAlign" value="middle"/&gt;
                &lt;add as="rounded" value="1"/&gt;
                &lt;add as="labelBackgroundColor" value="white"/&gt;
                &lt;add as="strokeColor" value="#36393D"/&gt;
                &lt;add as="strokeWidth" value="1"/&gt;
                &lt;add as="edgeStyle" value="elbowEdgeStyle"/&gt;
                &lt;add as="endArrow" value="classic"/&gt;
            &lt;/add&gt;
            &lt;add as="verticalConnector"&gt;
                &lt;add as="elbow" value="vertical"/&gt;
            &lt;/add&gt;
            &lt;add as="straightConnector"&gt;
                &lt;add as="shape" value="connector"/&gt;
                &lt;add as="endArrow" value="classic"/&gt;
                &lt;add as="edgeStyle"&gt;null&lt;/add&gt;
            &lt;/add&gt;
            &lt;add as="arrowConnector"&gt;
                &lt;add as="shape" value="arrow"/&gt;
                &lt;add as="fillColor" value="#C3D9FF"/&gt;
                &lt;add as="endSize" value="20"/&gt;
                &lt;remove as="edgeStyle"/&gt;
            &lt;/add&gt;
            &lt;add as="swimlane"&gt;
                &lt;add as="shape" value="swimlane"/&gt;
                &lt;add as="shadow" value="0"/&gt;
                &lt;add as="startSize" value="23"/&gt;
                &lt;add as="align" value="center"/&gt;
                &lt;add as="verticalAlign" value="top"/&gt;
                &lt;add as="strokeColor" value="#EEEEEE"/&gt;
                &lt;add as="fillColor" value="#D4D4D4"/&gt;
            &lt;/add&gt;
            &lt;add as="rounded"&gt;
                &lt;add as="rounded" value="1"/&gt;
            &lt;/add&gt;
            &lt;add as="ellipse"&gt;
                &lt;add as="shape" value="ellipse"/&gt;
                &lt;add as="perimeter" value="ellipsePerimeter"/&gt;
                &lt;add as="strokeColor" value="#CDEB8B"/&gt;
                &lt;add as="fillColor" value="#CDEB8B"/&gt;
            &lt;/add&gt;
            &lt;add as="doubleEllipse" extend="ellipse"&gt;
                &lt;add as="shape" value="doubleEllipse"/&gt;
            &lt;/add&gt;
            &lt;add as="rhombus"&gt;
                &lt;add as="shape" value="rhombus"/&gt;
                &lt;add as="perimeter" value="rhombusPerimeter"/&gt;
                &lt;add as="strokeColor" value="#FFCF8A"/&gt;
                &lt;add as="fillColor" value="#FFCF8A"/&gt;
            &lt;/add&gt;
            &lt;add as="triangle" extend="rhombus"&gt;
                &lt;add as="shape" value="triangle"/&gt;
                &lt;add as="perimeter" value="trianglePerimeter"/&gt;
                &lt;add as="align" value="left"/&gt;
            &lt;/add&gt;
            &lt;add as="hexagon"&gt;
                &lt;add as="shape" value="hexagon"/&gt;
            &lt;/add&gt;
            &lt;add as="actor"&gt;
                &lt;add as="shape" value="actor"/&gt;
                &lt;add as="strokeColor" value="#FFC7C7"/&gt;
                &lt;add as="fillColor" value="#FFC7C7"/&gt;
            &lt;/add&gt;
            &lt;add as="cloud"&gt;
                &lt;add as="shape" value="cloud"/&gt;
                &lt;add as="perimeter" value="ellipsePerimeter"/&gt;
                &lt;add as="strokeColor" value="#CDEB8B"/&gt;
                &lt;add as="fillColor" value="#CDEB8B"/&gt;
            &lt;/add&gt;
            &lt;add as="cylinder"&gt;
                &lt;add as="shape" value="cylinder"/&gt;
                &lt;add as="spacingTop" value="10"/&gt;
                &lt;add as="strokeColor" value="#4096EE"/&gt;
                &lt;add as="fillColor" value="#4096EE"/&gt;
            &lt;/add&gt;
            &lt;add as="hline"&gt;
                &lt;add as="shape" value="line"/&gt;
                &lt;add as="strokeWidth" value="3"/&gt;
                &lt;add as="perimeter" value="rectanglePerimeter"/&gt;
                &lt;add as="fontColor" value="black"/&gt;
                &lt;add as="fontSize" value="10"/&gt;
                &lt;add as="align" value="center"/&gt;
                &lt;add as="verticalAlign" value="bottom"/&gt;
                &lt;add as="strokeColor" value="#36393D"/&gt;
            &lt;/add&gt;
            &lt;add as="image"&gt;
                &lt;add as="shape" value="image"/&gt;
                &lt;add as="perimeter" value="rectanglePerimeter"/&gt;
                &lt;add as="fontSize" value="10"/&gt;
                &lt;add as="align" value="center"/&gt;
                &lt;add as="verticalAlign" value="middle"/&gt;
                &lt;add as="image" value="images/draw/mxlogo.jpg"/&gt;
            &lt;/add&gt;
        &lt;/mxStylesheet&gt;
        &lt;mxGraphModel as="model"&gt;
            &lt;add as="valueForCellChanged"&gt;&lt;![CDATA[
                function(cell, value)
                {
                    var previous = null;

                    if (value == null || isNaN(value.nodeType))
                    {
                        previous = cell.value.getAttribute('label');

                        if (value == null)
                        {
                            cell.value.removeAttribute('label');
                        }
                        else
                        {
                            cell.setAttribute('label', value);
                        }
                    }
                    else
                    {
                        previous = cell.value;
                        cell.value = value;
                    }

                    return previous;
                }
            ]]&gt;&lt;/add&gt;
            &lt;root&gt;
                &lt;Diagram label="My Diagram" href="http://www.mxgraph.com/" id="0"&gt;
                    &lt;mxCell/&gt;
                &lt;/Diagram&gt;
                &lt;Layer label="Default Layer" id="1"&gt;
                    &lt;mxCell parent="0"/&gt;
                &lt;/Layer&gt;
            &lt;/root&gt;
        &lt;/mxGraphModel&gt;
    &lt;/mxGraph&gt;
    &lt;!-- toolbar定义 --&gt;
    &lt;mxDefaultToolbar as="toolbar"&gt;
        &lt;add as="connect" mode="connect" icon="images/connect.gif"&gt;&lt;![CDATA[
            function (editor)
            {
                if (editor.defaultEdge != null)
                {
                    editor.defaultEdge.style = null;
                }
            }
        ]]&gt;&lt;/add&gt;
        &lt;add as="connect" mode="connect" icon="images/straight.gif"&gt;&lt;![CDATA[
            function (editor)
            {
                if (editor.defaultEdge != null)
                {
                    editor.defaultEdge.style = 'straightConnector';
                }
            }
        ]]&gt;&lt;/add&gt;
        &lt;add as="connect" mode="connect" icon="images/arrow.gif"&gt;&lt;![CDATA[
            function (editor)
            {
                if (editor.defaultEdge != null)
                {
                    editor.defaultEdge.style = 'arrowConnector';
                }
            }
        ]]&gt;&lt;/add&gt;
        &lt;br/&gt;&lt;br/&gt;
        &lt;add as="Text" template="text" icon="images/text.gif"/&gt;
        &lt;add as="Container" template="container" icon="images/swimlane.gif"/&gt;
        &lt;add as="Rectangle" template="rectangle" icon="images/rectangle.gif"/&gt;
        &lt;add as="Rounded" template="rounded" icon="images/rounded.gif"/&gt;
        &lt;add as="Ellipse" template="shape" style="ellipse" icon="images/ellipse.gif"/&gt;
        &lt;add as="Double Ellipse" template="shape" style="doubleEllipse" icon="images/doubleellipse.gif"/&gt;
        &lt;add as="Rhombus" template="shape" style="rhombus" icon="images/rhombus.gif"/&gt;
        &lt;add as="Triangle" template="actor" style="triangle" icon="images/triangle.gif"/&gt;
        &lt;add as="Hexagon" template="cloud" style="hexagon" icon="images/hexagon.gif"/&gt;
        &lt;add as="Actor" template="actor" style="actor" icon="images/actor.gif"/&gt;
        &lt;add as="Cylinder" template="shape" style="cylinder" icon="images/cylinder.gif"/&gt;
        &lt;add as="Cloud" template="cloud" style="cloud" icon="images/cloud.gif"/&gt;
        &lt;add as="Line" template="hline" style="hline" icon="images/hline.gif"/&gt;
        &lt;add as="Image" template="image" icon="images/image.gif"/&gt;
    &lt;/mxDefaultToolbar&gt;
&lt;/mxEditor&gt;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mxgraph笔记4【shape】]]></title>
    <link href="http://cocoo.github.com/blog/2013/03/07/mxgraphbi-ji4/"/>
    <updated>2013-03-07T12:54:00+08:00</updated>
    <id>http://cocoo.github.com/blog/2013/03/07/mxgraphbi-ji4</id>
    <content type="html"><![CDATA[<p>在mxgraph中，要实现一个自定义的图形使非常容易的。只需要：
*   继承mxShape
*   覆盖redrawPath方法
*   注册自定义的图形</p>

<!--more-->


<p>例子</p>

<pre><code>/**
 * Class: NoteShape
 * 
 * Implementation of the noteShape shape.
 *
 * Note Shape, supports size style
 * 
 * Constructor: NoteShape
 *
 * Constructs a new noteShape shape.
 */
function NoteShape() { };
/**
 * Extends &lt;mxCylinder&gt;.
 */
NoteShape.prototype = new mxCylinder();

NoteShape.prototype.constructor = NoteShape;
NoteShape.prototype.size = 30;

/**
 * Function: redrawPath
 *
 * Draws the path for this shape. This method uses the &lt;mxPath&gt;
 * abstraction to paint the shape for VML and SVG.
 */
NoteShape.prototype.redrawPath = function(path, x, y, w, h, isForeground)
{
    var s = Math.min(w, Math.min(h, mxUtils.getValue(this.style, 'size', this.size) * this.scale));

    if (isForeground)
    {
        path.moveTo(w - s, 0);
        path.lineTo(w - s, s);
        path.lineTo(w, s);
        path.end();
    }
    else
    {
        path.moveTo(0, 0);
        path.lineTo(w - s, 0);
        path.lineTo(w, s);
        path.lineTo(w, h);
        path.lineTo(0, h);
        path.lineTo(0, 0);
        path.close();
        path.end();
    }
};
// Register the NoteShape with note
mxCellRenderer.prototype.defaultShapes['note'] = NoteShape;
</code></pre>

<p>使用，这里直接给出在xml中使用</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mxgraph笔记3【toolbar】]]></title>
    <link href="http://cocoo.github.com/blog/2013/03/05/mxgraphbi-ji3/"/>
    <updated>2013-03-05T13:37:00+08:00</updated>
    <id>http://cocoo.github.com/blog/2013/03/05/mxgraphbi-ji3</id>
    <content type="html"><![CDATA[<p>用给定的dom元素创建一个toolbar，这个toolbar可能包含icons，buttons和combo boxes</p>

<!--more-->


<p>例子</p>

<pre><code>&lt;div id="sidebar"&gt;
    &lt;ul style="display: block;"&gt;
        &lt;li class="submenu"&gt;
            &lt;a href="#"&gt; &lt;i class="icon icon-white icon-inbox"&gt;&lt;/i&gt;
                &lt;span&gt;基本&lt;/span&gt;
                &lt;span class="label"&gt;3&lt;/span&gt;
            &lt;/a&gt;
            &lt;ul id="toolbar-basic"&gt;
            &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li class="submenu"&gt;
            &lt;a href="#"&gt; &lt;i class="icon icon-white icon-th-list"&gt;&lt;/i&gt;
                &lt;span&gt;图形&lt;/span&gt;
                &lt;span class="label"&gt;3&lt;/span&gt;
            &lt;/a&gt;
            &lt;ul id="toolbar-shpae"&gt;
            &lt;/ul&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
...
// Creates the div for the toolbar basic
var containerBasic = document.getElementById('toolbar-basic');

var toolbarBasic = new mxToolbar(containerBasic);
toolbarBasic.enabled = false;

new mxDivResizer(containerBasic);

// Creates the div for the toolbar basic
var containerShape = document.getElementById('toolbar-shape');

var toolbarShape = new mxToolbar(containerShape);
toolbarShape.enabled = false;

new mxDivResizer(containerShape);
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mxgraph笔记1【简介】]]></title>
    <link href="http://cocoo.github.com/blog/2013/03/04/mxgraphbi-ji1/"/>
    <updated>2013-03-04T14:53:00+08:00</updated>
    <id>http://cocoo.github.com/blog/2013/03/04/mxgraphbi-ji1</id>
    <content type="html"><![CDATA[<h2>简介</h2>

<p>mxGraph客户端是一个图形组件，并提供和网页集成的接口。。客户端需要一个Web服务器提供所需的文件，也可以在本地文件系统上运行。后台可用于集成到现有存在的服务器所支持的语言中
与后台配合后， 该组件可完成以下功能：</p>

<ul>
<li><p>创建类似visio的图库</p></li>
<li><p>存储加载图库</p></li>
<li><p>创建一个graph对象</p></li>
<li><p>与其他客户共享图库</p></li>
</ul>


<p>提交</p>

<!--more -->


<p>上述几种方式可以结合起来应用，如发送更改配置的XML文件到后台，或自动保存图形以免数据丢失。并且客户端可以本地化操作。</p>

<h2>例子 Hello, World!</h2>

<h3>引入库文件</h3>

<p>网页头部包含javascript代码和依赖关系。用以下代码来加载库文件。mxBasePath变量用来定义库资源的目录。这个变量必须在加载库前就定义好。</p>

<pre><code>&lt;script type="text/javascript"&gt;
  mxBasePath = 'javascript/src/';
&lt;/script&gt;
&lt;script type="text/javascript" src="javascript/src/js/mxClient.js"&gt;&lt;/script&gt;
</code></pre>

<p>mxClient.js包含全部所需代码。注意：资源代码仅仅商业发行。在评估版本中这个文件是一个来自服务器的URL链接。不可以本地化源代码。</p>

<h3>检查浏览器</h3>

<p>下一个script标签包含hello world的代码。代码的第一部分是检查浏览器是否支持mxgraph。 建议在编码前做这步，如果浏览器不支持就能在此显示错误信息。一般来说, js脚本代码应该和html代码分开，但这个例子中没这样做。</p>

<p>对于主函数function main（）{}没有什么特殊的规定。function引用头部加载的文件，并且可以有任何名称包含任何参数。在这个例子中参数是body中的dom节点。注意： 以下代码和dom节点的id无关</p>

<pre><code>&lt;script type="text/javascript";&gt;
function main(container)
{
  // Checks if the browser is supported
//检查浏览器是否支持
  if (!mxClient.isBrowserSupported())
  {
    // Displays an error message if the browser is not supported.
//如果浏览器不支持，则显示错误信息
    mxUtils.error('Browser is not supported!', 200, false);
  }
  ...
</code></pre>

<h2>Container 容器</h2>

<p>页面用一个dom节点将graph与javascript结合。它可以使用document.getElementById在body中取得（如这个例子）或者直接动态创建（如createElement， 译者注）。dom节点传递到主函数中用于建立以下graph例子。</p>

<p>如果你想让容器中有滚动条，那么将容器样式的属性 overflow 设为auto。</p>

<h2>Graph 图</h2>

<p>代码创建了一个空的graph图模型并通过容器和空的模型来构建具体的图。在这个例子中，所有默认事件处理在最后一行将失效。（mxgraph使用典型的MVC模式， 熟悉MVC模式的读者更容易上手。 译者注）</p>

<pre><code>var model = new mxGraphModel();
var graph = new mxGraph(container, model);
如果你希望graph图只读，可用 graph.setEnabed(false).
</code></pre>

<h2>Vertices （节点）and Edges（连线）</h2>

<p>程序需要在beginUpdate和endUpdate中来插入节点和连线（更新图形）。endUpdate应放在finally-block中以确保endUpdate一直执行。但beginUpdate不能在try-block中，这样如果beginUpdate失败那么endupdate永远不会执行。</p>

<p>块内的部分为图形创建节点和连线。默认的父节点是在用graph时无需参数自动创建在图中根节点的第一个子节点。</p>

<pre><code>// Gets the default parent for inserting new cells. This
// is normally the first child of the root (ie. layer 0).
//为插入节点获得默认的父节点。



  //这通常是根节点的第一个子节点
var parent = graph.getDefaultParent();

// Adds cells to the model in a single step
//在单独的一步中添加cell
model.beginUpdate();
try
{
  var v1 = graph.insertVertex(parent, null, 'Hello,', 20, 20, 80, 30);
  var v2 = graph.insertVertex(parent, null, 'World!', 200, 150, 80, 30);
  var e1 = graph.insertEdge(parent, null, '', v1, v2);
}
finally
{
  // Updates the display
//更新显示
  model.endUpdate();
}
</code></pre>

<p>beginUpdate&amp;endUpdate不仅提供了显示功能，而且它能够当做undo/redo标记的边界（也就是说，beginUpdate和endUpdate之间操作会作为Undo、redo的原子操作，要么同时被redo或undo， 相当于数据库中的事务）</p>

<h2>Graphs 图</h2>

<p>将dom节点实例化为一个graph图：</p>

<pre><code>var node = document.getElementById('id-of-graph-container');
var graph = new mxGraph(node);
</code></pre>

<h2>Model 编程模型</h2>

<p>mxcell在mxGraphModel中实现了定义图模型的元素。
图模型有以下属性（包含关系）：
根节点包含各个层，各个层的父节点都是根节点。
层中可包含graph图模型的元素：节点、连线组。
组中可递归的包含graph图模型的元素。
graph图的结构和信息都存储在cell和用户对象中。（又名业务对象）</p>

<p>用一个根节点和默认的层来创建一个新的graph模型：</p>

<pre><code>var root = new mxCell();
root.insert(new mxCell());
var model = new mxGraphModel(root);
</code></pre>

<h2>Stylesheet 样式表</h2>

<p>cell的样式由样式表（mxStylesheet的实例）来决定。样式表规定了样式名称到样式之间的映射关系。一个样式是一个键的数组。那些键对应所用cell的值。值在mxConstants中定义，可以是字符串和数字、javascript对象、函数等 。 修改节点和连线的默认样式：</p>

<pre><code>var vertexStyle = graph.getStylesheet().getDefaultVertexStyle();
vertexStyle[mxConstants.ROUNDED] = true;

var edgeStyle = graph.getStylesheet().getDefaultEdgeStyle();
edgeStyle[mxConstants.STYLE_EDGE] = mxEdgeStyle.TopToBottom;
</code></pre>

<h2>Styles 样式</h2>

<p>cell的样式在属性style中（cell.style）。样式是cell状态的一部分，它可以通mxGraphModel.setStyle来改变。style是form[stylename;|key=value;]中的一段字符串。默认样式可覆盖此cell的制定键值。例如：你用 rounded 样式，它可以覆盖 stroke和fillColor，样式被这样定义：</p>

<pre><code>[stylename;|key=value;]
</code></pre>

<h2>Appearance 显示外观</h2>

<p>在具体项目中你也许需要自定义cell的那些动态特性（就是外观），例如 图形、指针形状、颜色等。你可以分别用以下方法： getImage, getIndicatorShape, getIndicatorImage, getIndicatorColor ，getIndicatorGradientColor&#8230;。注意：这些方法作为一个参数，它指向一个cell的style&#8221;解决&#8221;（即数组）版本的cell状态。因此，对getImage默认实现如下所示：</p>

<pre><code>mxGraph.prototype.getImage = function(state)
{
  if (state != null &amp;&amp; state.style != null)
  {
    return state.style[mxConstants.STYLE_IMAGE];
  }
  return null;
}
</code></pre>

<p>这个方法可把cell的图形改成任何你需要的。通常，图像被定义为state.cell指向cell关联的状态或state.cell.value指向用户对象。
为了使改变可以显示出来，你需要调用view.invalidate(cell)和view.validate</p>

<h2>Editors 编辑器</h2>

<p>程序通过初始化mxEditor来创建编辑器。这是编辑器包的核心类。其他都是辅助类。可通过配置文件名称创建并配置一个编辑器。</p>

<p>请看下面的例子：</p>

<pre><code>var config = mxUtils.load('editors/config/keyhandler-commons.xml').getDocumentElement();
var editor = new mxEditor(config);
</code></pre>

<p>xml格式的配置文件会传递给mxCodec，mxCodec使用mxEditorCodec和其他编码将xml文件读入编辑器对象层次结构中。通常在编辑器开始构件时进行，graph, model, toolbar, popupmenus等用 I/O subsystem</p>

<h2>CSS</h2>

<p>Css样式表单包含多种用户接口元素（选择框，编辑器，弹出菜单等）的样式的定义。它也包含允许应用XML配置文件来支持IE的指令，因此页面中有大量的这种表单。</p>

<p>可以通过mxClient.link(&#8216;stylesheet&#8217;, filename)或者表单标签来配置编辑器。例：</p>

<pre><code>&lt;mxEditor&gt;
  &lt;ui&gt;
    &lt;stylesheet name="examples/editors/css/process.css"/&gt;
    ...
</code></pre>

<h2>Templates 模板</h2>

<p>按如下，通过在配置文件中的节点定义新的cell类型模板</p>

<pre><code>&lt;add as="symbol"&gt;
  &lt;Symbol label="Symbol" customAttribute="whatever"&gt;
    &lt;mxCell vertex="1" connectable="1" style="symbol;image=images/event.png"&gt;    
      &lt;mxGeometry as="geometry" width="32" height="32"/&gt;
    &lt;/mxCell&gt;
    &lt;CustomChild customAttribute="whatever"/&gt;
  &lt;/Symbol&gt;
&lt;/add&gt;
</code></pre>

<p>add元素的as属性包含模板上一次成功应用的名称，Symbol子节点元素是一个ie或者火狐的客户端元素，可以有任何名称和任意多的子节点以及客户属性。标签属性是对图形单元的文字表述。mxCell元素是另一个特殊的子节点包含cell的图像化信息，并命名其为 cell-type, -style, -size ， -position.等</p>

<h2>Toolbar</h2>

<p>按如下，必须通过在配置文件中配置mxDefaultToolbar节(mxEditor /mxDefaultToolbar[as=toolbar]) 来应用Toolbar模板。</p>

<pre><code>&lt;add as="symbolTool" template="symbol"
  style="symbol;image=wf/images/bpmn/special_event.png"
  icon="wf/images/bpmn/small_event.gif"/&gt;
</code></pre>

<p>as属性指定工具标签在工具栏中显示，template属性指定最先被加载的模板，style属性是可选的，用于重写默认的style。icon属性指定了toolbar自身的图形样式。
注：在这个symbolTool的例子中，as属性被规定为语言资源的键值。如果资源在mxResource中没有定义，那么属性值将被作为标签。</p>

<p>以上尽简单介绍，会在后续中详细讨论。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[rabbitmq环境搭建]]></title>
    <link href="http://cocoo.github.com/blog/2013/02/19/rabbitmqhuan-jing-da-jian/"/>
    <updated>2013-02-19T10:11:00+08:00</updated>
    <id>http://cocoo.github.com/blog/2013/02/19/rabbitmqhuan-jing-da-jian</id>
    <content type="html"><![CDATA[<h2>目录</h2>

<ul>
<li><a href="#introduction">简介</a></li>
<li><a href="#install">安装</a>

<ul>
<li> <a href="#erlang-install">erlang 安装</a></li>
<li> <a href="#rabbitmq-install">rabbitmq 安装</a></li>
</ul>
</li>
</ul>


<!-- more-->


<div id="introduction"></div>


<h2>简介</h2>

<p>MQ全称为Message Queue, 消息队列（MQ）是一种应用程序对应用程序的通信方法。应用程序通过写和检索出入列队的针对应用程序的数据（消息）来通信，而无需专用连接来链接它们。消 息传递指的是程序之间通过在消息中发送数据进行通信，而不是通过直接调用彼此来通信，直接调用通常是用于诸如远程过程调用的技术。排队指的是应用程序通过 队列来通信。队列的使用除去了接收和发送应用程序同时执行的要求。其中较为成熟的MQ产品有IBM WEBSPHERE MQ。</p>

<div id="install"></div>


<h2>安装</h2>

<div id="erlang-install"></div>


<h3>erlang 安装</h3>

<p>erlang的安装不在这里赘述，网上很多这方面的教程。注意下把环境变量配置下即可，我装的使R15B01</p>

<div id="rabbitmq-install"></div>


<h3>rabbitmq 安装</h3>

<pre><code>wget http://www.rabbitmq.com/releases/rabbitmq-server/v3.0.2/rabbitmq-server-generic-unix-3.0.2.tar.gz
tar xvzf rabbitmq-server-generic-unix-3.0.2.tar.gz
cp -R rabbitmq_server-3.0.2 /usr/local/rabbitmq
</code></pre>

<h3>rabbitmq 基本配置和使用</h3>

<p>修改默认配置文件路径</p>

<pre><code>vi /usr/local/rabbitmq/sbin/rabbitmq-defaults
SYS_PREFIX=
</code></pre>

<p>新建配置文件</p>

<pre><code>vi /etc/rabbitmq/rabbitmq-env.conf
#Rename the node
#NODENAME=bunny@myhost
#Config file location and new filename bunnies.config
CONFIG_FILE=/etc/rabbitmq/rabbitmq.config

vi /etc/rabbitmq/rabbitmq.config

[
  {rabbit,                    [ {tcp_listeners,               [5672]},
                                {collect_statistics_interval, 10000} ] },
  {rabbitmq_management,       [ {http_log_dir,          "/tmp/rabbit-mgmt"},
                                {listener,              [{port, 55672}]} ] },
  {rabbitmq_management_agent, [ {force_fine_statistics, true} ] }
].
</code></pre>

<p>开启web管理</p>

<pre><code>/usr/local/rabbitmq/sbin/rabbitmq-plugins enable rabbitmq_management 
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Backbone学习1]]></title>
    <link href="http://cocoo.github.com/blog/2013/01/28/backbonexue-xi-1/"/>
    <updated>2013-01-28T12:50:00+08:00</updated>
    <id>http://cocoo.github.com/blog/2013/01/28/backbonexue-xi-1</id>
    <content type="html"><![CDATA[<h2>Backbone 简介</h2>

<p>Backbone 是一个前端 JS 代码 MVC 框架，被著名的 <a href="http://37signals.com/">37signals</a> 用来构建他们的移动客户端。它不可取代 Jquery，不可取代现有的 template 库。而是和这些结合起来构建复杂的 web 前端交互应用。</p>

<p>如果项目涉及大量的 javascript 代码，实现很多复杂的前端交互功能，首先你会想到把数据和展示分离。使用 Jquery 的 selector 和 callback 可以轻松做到这点。但是对于富客户端的WEB应用大量代码的结构化组织非常必要。</p>

<p>Backbone 就提供了 javascript 代码的组织的功能。Backbone 主要包括 models, collections, views 和 events, controller 。</p>

<p>Models 用来创建数据，校验数据，存储数据到服务器端， Collections 包含你创建的 functions ，Views 用来展示数据。</p>

<p>Models 还可以绑定事件。比如用户动作变化触发 models 的 change 事件，所有展示此model 数据的 views 都会接收到 这个 change 事件，进行重绘。</p>

<p>Backbone托管在github上,地址:<a href="https://github.com/documentcloud/backbone">Backbone</a></p>

<h3>例子</h3>

<p>`</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[搭建nginx+mongodb+fastdfs]]></title>
    <link href="http://cocoo.github.com/blog/2013/01/21/da-jian-nginx-plus-mongodb-plus-fastdfs/"/>
    <updated>2013-01-21T11:11:00+08:00</updated>
    <id>http://cocoo.github.com/blog/2013/01/21/da-jian-nginx-plus-mongodb-plus-fastdfs</id>
    <content type="html"><![CDATA[<h2>1.   nginx</h2>

<p>此次所需插件：</p>

<blockquote><ol>
<li>nginx-upstream-fair</li>
<li>nginx_upload_module</li>
<li>ngx_http_auth_request_module</li>
<li>fastdfs-nginx-module</li>
</ol>
</blockquote>

<!-- more-->


<ol>
<li>nginx-upstream-fair</li>
</ol>


<p>“公平的”Nginx 负载均衡模块，增强了Nginx 提供的round-robin 负载均衡算法，可以跟踪后端服务器的负载来分发请求。</p>

<p>下载：</p>

<pre><code>git clone git://github.com/gnosek/nginx-upstream-fair.git
</code></pre>

<p>配置范例：</p>

<pre><code>upstream mongrel {
    fair;
    server 127.0.0.1:5000;
    server 127.0.0.1:5001;
    server 127.0.0.1:5002;
}
</code></pre>

<ol>
<li>nginx_upload_module</li>
</ol>


<p>nginx upload module模块通过nginx服务器来接受用户上传的文件，它自动分析客户端的上传请求，将上传的文件保存到 upload_store 所指向的目录位置。
然后这些文件信息将被从原始的请求中剔除，重新组装好上传参数后转交到后端由 upload_pass 指定的location去处理，这样后端就可以任意处理上传的文件。
每一个上传的 file 字段值将可以由upload_set_form_field 指定的值替换。
上传的文件可以通过$upload_tmp_path 变量访问到。
上传的文件经过处理以后，由 upload_cleanup 指定的条件控制删除清理。</p>

<p>下载:</p>

<pre><code>git clone git://github.com/vkholodkov/nginx-upload-module.git
</code></pre>

<ol>
<li>ngx_http_auth_request_module</li>
</ol>


<p>这个模块可以实现基于服务器内部子请求的返回结果来控制用户鉴权。比如子请求返回4xx则提示说没有权限，如果是2xx则会返回资源给客户端，返回401错误则把子请求的鉴权头透传给客户端。这样通过服务器内部逻辑就可以控制鉴权，省去不少业务逻辑层的脚本代码.</p>

<p>下载:</p>

<pre><code>git clone git://github.com/PiotrSikora/ngx_http_auth_request_module.git
</code></pre>

<p>Usage:</p>

<pre><code>location /private/ {
    auth_request /auth;
    ...
}

location = /auth {
    proxy_pass ...
    proxy_pass_request_body off;
    proxy_set_header Content-Length "";
    proxy_set_header X-Original-URI $request_uri;
}
</code></pre>

<ol>
<li>fastdfs-nginx-module</li>
</ol>


<p>下载:</p>

<pre><code>wget http://fastdfs-nginx-module.googlecode.com/files/fastdfs-nginx-module_v1.14.tar.gz
tar xzvf fastdfs-nginx-module_v1.14.tar.gz
</code></pre>

<p>最后是nginx</p>

<pre><code>wget http://nginx.org/download/nginx-1.2.1.tar.gz
tar xzvf nginx-1.2.1.tar.gz
cd nginx-1.2.1
./configure --with-http_ssl_module --with-http_flv_module --with-http_gzip_static_module --with-mail --with-mail_ssl_module --with-poll_module --with-http_stub_status_module --with-http_perl_module --add-module={nginx_plugin_path}/nginx-upstream-fair --add-module={nginx_plugin_path}/nginx-upload-module --add-module={nginx_plugin_path}/ngx_http_auth_request_module --add-module={nginx_plugin_path}/fastdfs-nginx-module/src/
make &amp;&amp; make install
</code></pre>

<p>在make的时候会报错,没有fdfs_define.h,那是因为还没有安装fastdfs.先安装fastdfs,回头再来编译nginx</p>

<h2>2.   fastdfs</h2>

<p>FastDFS是一款类Google FS的开源分布式文件系统，它用纯C语言实现，支持Linux、FreeBSD、AIX等UNIX系统。它只能通过专有API对文件进行存取访问，不支持POSIX接口方式，不能mount使用。准确地讲，Google FS以及FastDFS、mogileFS、HDFS、TFS等类Google FS都不是系统级的分布式文件系统，而是应用级的分布式文件存储服务。</p>

<p>依赖libevent:</p>

<pre><code>wget http://cloud.github.com/downloads/libevent/libevent/libevent-1.4.14b-stable.tar.gz
cd libevent-1.4.14b
./configure
make &amp;&amp; make install
</code></pre>

<p>安装Fastdfs:</p>

<pre><code>wget http://fastdfs.googlecode.com/files/FastDFS_v4.05.tar.gz
tar xzvf FastDFS_v4.05.tar.gz
cd FastDFS
./make &amp;&amp; ./make install
</code></pre>

<p>配置Fastdfs:</p>

<pre><code>mkidr -p /home/data/fastdfs/db
mkidr -p /home/data/fastdfs/log
vi /etc/fdfs/tracker.conf 
修改base_path=/home/data/fastdfs
vi /etc/fdfs/storage.conf
修改base_path=/home/data/fastdfs
修改tracker_server=192.168.1.100:22122
</code></pre>

<p>以上配置根据自己的电脑进行配置
启动:</p>

<pre><code>fdfs_trackerd /etc/fdfs/tracker.conf 
fdfs_storaged /etc/fdfs/storage.conf
</code></pre>

<p>监控:</p>

<pre><code>fdfs_monitor /etc/fdfs/client.conf
</code></pre>

<p>测试:</p>

<pre><code>fdfs_upload_file /etc/fdfs/client.conf test.tx
返回:group1/M00/00/00/wKgBZFELUiCAMJzqAAAABmpcy6c9964.tx
fdfs_download_file /etc/fdfs/client.conf group1/M00/00/00/wKgBZFELUiCAMJzqAAAABmpcy6c9964.tx test.tx
</code></pre>

<p>重新回到之前编译nginx的地方.</p>

<pre><code>./configure --with-http_ssl_module --with-http_flv_module --with-http_gzip_static_module --with-mail --with-mail_ssl_module --with-poll_module --with-http_stub_status_module --with-http_perl_module --add-module={nginx_plugin_path}/nginx-upstream-fair --add-module={nginx_plugin_path}/nginx-upload-module --add-module={nginx_plugin_path}/ngx_http_auth_request_module --add-module={nginx_plugin_path}/fastdfs-nginx-module/src/

make &amp;&amp; make install
</code></pre>

<p>耐心等待,应该没有什么问题.
配置nginx.conf</p>

<pre><code>vi /etc/nginx/nginx.conf
</code></pre>

<p>增加:</p>

<pre><code>location ~ ^/group1/M00/ {
            root /home/data/fastdfs/data;
            expires 4d;
            ngx_fastdfs_module;
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[学会octopress的思考方式]]></title>
    <link href="http://cocoo.github.com/blog/2013/01/20/xue-hui-octopressde-si-kao-fang-shi/"/>
    <updated>2013-01-20T20:55:00+08:00</updated>
    <id>http://cocoo.github.com/blog/2013/01/20/xue-hui-octopressde-si-kao-fang-shi</id>
    <content type="html"><![CDATA[<p>新近接触octopress，一直想写自己的博客，我是一名coder。想用coder的方式写博客，所以选择了octopress。选择她，就要学会她的思考方式。</p>

<!-- more-->


<p>昨晚刚刚完成了sublime text2 在ubuntu12.04下输入中文法，今晚就迫不及待的想用这个我一直coding的ide写篇博文。
其实要完成这个很简单，完成下面这个命令即可：</p>

<pre><code>apt-get install fcitx
</code></pre>

<p>我想学会octopress的思考方式应该从这几点入手：</p>

<blockquote><ol>
<li>学会用她.</li>
<li>尝试个性化.</li>
</ol>
</blockquote>

<p>1.学会用她</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux学习之crontab]]></title>
    <link href="http://cocoo.github.com/blog/2013/01/19/linuxxue-xi-zhi-crontab/"/>
    <updated>2013-01-19T21:35:00+08:00</updated>
    <id>http://cocoo.github.com/blog/2013/01/19/linuxxue-xi-zhi-crontab</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
</feed>
